<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[每日练习之递归]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[习题1：递归和非递归分别实现求第n个斐波那契数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;//斐波那契数，非递归/*int fibo(int num)&#123; int arr[4] = &#123; 0, 1, 1&#125;; int i = 0; if(num&lt;=2) &#123; return 1; &#125; for(i=3; i&lt;=num; i++) &#123; arr[3] = arr[2] + arr[1]; arr[1] = arr[2]; arr[2] = arr[3]; &#125; return arr[3];&#125;*///递归int fibo(int num)&#123; if( num &lt;= 2 ) &#123; return 1; &#125; return fibo(num-1)+fibo(num-2);&#125;int main()&#123; int num = 0; int ret = 0; do&#123; printf(&quot;Enter: 1-45\n&quot;); scanf(&quot;%d&quot;, &amp;num); &#125;while(num&lt;0 || num&gt;=45); ret = fibo(num); printf(&quot;第%d个fibo数为：%d\n&quot;, num, ret); return 0;&#125; 习题2：编写一个函数实现n^k，使用递归实现 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int my_power(int n, int k)&#123; if(k == 1) &#123; return n; &#125; if(k == 0) &#123; return 1; &#125; return my_power(n, k-1)*n;&#125;int main()&#123; int n = 0; int k = 0; int ret = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ret = my_power(n, k); printf(&quot;%d^%d = %d\n&quot;, n, k, ret); return 0;&#125; 习题3：写一个递归函数DigitSum(n)，输入一个非负整数，返回组成它的数字之和，例如，调用DigitSum(1729)，则应该返回1+7+2+9，它的和是19 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int DigitSum(int n)&#123; if(n&lt;10) return n; return DigitSum(n/10)+(n%10);&#125;int main()&#123; int num = 0; int ret = 0; do&#123; printf(&quot;Enter: &gt;0.\n&quot;); scanf(&quot;%d&quot;, &amp;num); &#125;while(num &lt;= 0); ret = DigitSum(num); printf(&quot;%d\n&quot;, ret); return 0;&#125; 习题4编写一个函数reverse_string(char * string)（递归实现）实现：将参数字符串中的字符反向排列。要求：不能使用C函数库中的字符串操作函数。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void reverse_string(char * str)&#123; assert(str); if(*str != &apos;\0&apos;) &#123; str++; reverse_string(str); printf(&quot;%c&quot;, *(str-1)); &#125;&#125;int main()&#123; char arr[] = &quot;Hello everybody&quot;; reverse_string(arr); putchar(&apos;\n&apos;); return 0;&#125; 习题5、递归和非递归分别实现strlen 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;assert.h&gt;int my_strlen(const char * str)&#123; assert(str); if(!*str) return 0; else return 1 + my_strlen(str+1);&#125;//非递归/*int my_strlen(const char * str)&#123; int count = 0; assert(str); while(*str != &apos;\0&apos;) //开始又忘记解引用了，迷醉 &#123; str++; count++; &#125; return count;&#125;*/int main()&#123; char arr[] = &quot;abcsdf&quot;; int ret = 0; ret = my_strlen(arr); printf(&quot;%d\n&quot;, ret); return 0;&#125; 习题6、递归和非递归分别实现求n的阶乘 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;assert.h&gt;//非递归/*int jiecheng(int n)&#123; int i = 0; int sum = 1; for(i=1; i&lt;=n; i++) &#123; sum *= i; &#125; return sum;&#125;*/int jiecheng(int n)&#123; if(n == 1) return 1; return n*jiecheng(n-1);&#125;int main()&#123; int n = 0; int ret = 0; scanf(&quot;%d&quot;, &amp;n); ret = jiecheng(n); printf(&quot;%d! = %d\n&quot;, n, ret); return 0;&#125; 习题7递归方式实现打印一个整数的每一位 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void my_print(int num)&#123; if(num &lt;10) &#123; printf(&quot;%d &quot;, num); &#125; else &#123; my_print(num/10); printf(&quot;%d &quot;, num%10); &#125; &#125;int main()&#123; int num = 0; scanf(&quot;%d&quot;, &amp;num); my_print(num); return 0;&#125;]]></content>
      <categories>
        <category>每日练习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之栈帧]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[习题1：实现一个函数，可以左旋字符串中的k个字符。ABCD左旋一个字符得到BCDAABCD左旋两个字符得到CDAB 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void zuoxuan(char *str, int num)&#123; char tmp; char *dst = str; assert(str); while(num) &#123; str = dst; tmp = *str; while(*(str+1)) &#123; *str = *(str+1); str++; &#125; *str = tmp; num--; &#125;&#125;int main()&#123; char ch[15] = &quot; &quot;; int num = 0; scanf(&quot;%d&quot;, &amp;num); //获取左旋的个数 scanf(&quot;%s&quot;, ch); //获取字符串 zuoxuan(ch, num); printf(&quot;%s\n&quot;, ch); return 0;&#125; 在写程序中遇到的问题：把指针没有解引用，一直对指针做运算，程序没有输出结果，发现是没有解引用。 习题2:判断一个字符串是否为另外一个字符串旋转之后的字符串。例如：给定s1 ＝ AABCD和s2 = BCDAA，返回1，给定s1=abcd和s2=ACBD，返回0. AABCD左旋一个字符得到ABCDAAABCD左旋两个字符得到BCDAA AABCD右旋一个字符得到DAABC 理解：这个题目和第一个题目类似，上边的字符串右旋一个字符就相当于左旋两个字符。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;int judge(char *str1, char *str2, int size) //代码的缺点是在翻转时改变了原来的字符串&#123; char tmp; char *dst = str1; assert(str1); assert(str2); while(size) &#123; str1 = dst; if(strcmp(str1,str2) == 0) return 1; tmp = *str1; while(*(str1+1)) &#123; *str1 = *(str1+1); str1++; &#125; *str1 = tmp; size--; &#125; return 0;&#125;int main()&#123; char s1[] = &quot;ABCDEF&quot;; //源字符串 char s2[] = &quot;DEFABC&quot;; //要判断的字符串 int ret = 0; int size = strlen(s1); ret = judge(s1, s2, size); if(ret == 0) &#123; printf(&quot;No.\n&quot;); &#125; else &#123; printf(&quot;Yes.\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>每日练习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈帧与函数的调用]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[测试环境: vc2008 1、什么是栈 在计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop）,但栈这个容器必须遵守一条规则：先入栈的数据后出栈，多多少少像叠起来的一叠书，先叠上去的书在最下面，因此最后才能取出。 程序栈的简图 这里的ebp表示栈低寄器，esp表示栈顶寄存器，在栈上压入数据会导致esp减少，弹出数据会使得esp增大。相反，直接减小esp的值相当于开辟空间，增大esp的值相当于回收空间。 2、一个很常见的活动记录 活动记录 3、我们来看一个看例子 接下来，我们用一个简单的程序来说明函数的调用以及栈的布局 1234567891011121314151617181920#include &lt;stdio.h&gt;int fun(int a, int b)&#123; int z = a + b; return z;&#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c = fun(a, b); printf(&quot;c = %d&quot;, c); return 0;&#125; 这里我们直接进行调试，通过汇编代码能看的更去清楚。我们先从main函数开始 这里需要强调的是call命令，它有两个作用： 把当前指令的下一条指令的地址压入栈中 跳转到函数体执行到这里可能有人会想，cpu怎么知道我这会执行到那条代码，它是怎样计算的呢，在这里我们还需要知道一个寄存器，EIP寄存器（也叫程序计数器），它总是指向当前指令的下一条指令的地址。下来我们进入fun函数体 这样我就进入到了fun函数内部，当fun函数执行完时，执行123011013DD mov esp,ebp 011013DF pop ebp 011013E0 ret 使esp=ebp； 然后让 old ebp出栈，至此ebp就回到了main函数的ebp，ret从栈中去出返回地址，并跳到此处。101101429 add esp,8 紧接着又执行了这句，使esp指向main函数的栈顶。 fun函数的这段汇编代码基本分为下面几步：1.保存edp，让edp指向目前的栈顶1200E913B0 push ebp 00E913B1 mov ebp,esp 2.在栈上开辟一块空间100E913B3 sub esp,0CCh 3.保存ebx，esi，edi寄存器12300E913B9 push ebx 00E913BA push esi 00E913BB push edi 4.加入调试信息123400E913BC lea edi,[ebp-0CCh] 00E913C2 mov ecx,33h 00E913C7 mov eax,0CCCCCCCCh 00E913CC rep stos dword ptr es:[edi] 5.返回z，在这里是返回值通过eax寄存器传回100E913D7 mov eax,dword ptr [z] 6.从栈上恢复edi，esi，ebx寄存器12300E913DA pop edi 00E913DB pop esi 00E913DC pop ebx 7.恢复进入函数前的esp和edp1200E913DD mov esp,ebp 00E913DF pop ebp 8.使用ret指令返回100E913E0 ret 特别注意：main函数也是一个被调函数，因此调用它的过程和调用fun函数基本类似 4、通过栈帧修改ret返回的地址这里我们调用fun函数后，不让ret返回到main函数，而是修改它的地址，让他来到bug函数，将栈中存的返回地址保存到全局变量ret中，执行完bug函数后，让函数在返回main函数测试环境为vc6.0 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 执行结果如图： 但是一按回车就会出错，原因是call命令会把当前命令的下一条指令的地址压入栈中，执行完后会跳转到函数体。但是我们调用BUG函数时没有通过call命令调用，因此，我们少push一次，按回车后的esp应该指向的是main-esp-4；因此我们需要在main函数里调用完fun函数后将esp+4，保持栈帧平衡， 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); __asm &#123; sub esp, 4; &#125; printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 执行结果如图：]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>栈帧</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018目标]]></title>
    <url>%2F2018%2F03%2F05%2F2018%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;今天是开学的第一天，大三的第二学期，再过半年就面临找工作了，由于自己想要找IT方面的工作，因此要付出更多的努力，今后一定不能浪费时间， 蓝桥杯&ensp;&ensp;&ensp;现在是3/15，距离蓝桥杯开始还有25天，我还没有做准备，今天晚上看了看题，很慌张，自己的C语言水平是如此的低，因此在这25天里，重点突击蓝桥杯，多做题，多思考，争取取得好成绩。 四级&ensp;&ensp;&ensp;从大一到现在已经考了三次四级，这次总算过了校线，前两次因为自己的英语差，以及裸考成绩都不如人意，这学期也将四级最为重点，争取在6月份考过四级，期待七月份的好成绩。 C++&ensp;&ensp;&ensp;从上学期十二月份开始，自己将方向定为C++，因为不喜欢本专业，也不考研，因此转向IT，之前学过C语言，搞过单片机，因为单片机对C语言的要求不高，因此我的C语言水平也比较差。从这学期开始，好好学习计算机类课程，提高自己的实力，争取在秋招找到一份好工作。 博客&ensp;&ensp;&ensp;定时的更新博客，每周至少写两篇技术博客，算是对自己学习的督促，和对知识的总结吧。 2018加油！ &ensp;&ensp;&ensp;&ensp;&ensp;fighting！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my blog 搭建完成]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[搭建博客一直都想有一个自己的博客，今使用 GitHub 时看见 GitHub+Hexo 也可以搭建静态博客，便产生了搭建博客的想法，于是便开始着手搭建。本博客于2018/3/1开始搭建，于2018/3/3基本搭建完成，后期继续优化。 搭建博客的目的用于写技术博客，也用于记录生活,后期会持续的定时更新博客。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.3.1]]></title>
    <url>%2F2018%2F03%2F01%2F2018-3-1%2F</url>
    <content type="text"><![CDATA[要狠心，要改过自新，要向前看，要赢。]]></content>
  </entry>
</search>
