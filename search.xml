<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux学习笔记一]]></title>
    <url>%2F2018%2F03%2F25%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[指针和数组的经典习题]]></title>
    <url>%2F2018%2F03%2F24%2F%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%8F%E5%85%B8%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[练习1：12345678910#include &lt;stdio.h&gt;int main()&#123; int a[5] = &#123;1,2,3,4,5&#125;; int *ptr = (int*)(&amp;a+1); printf(&quot;%d,%d&quot;, *(a+1), *(ptr-1)); return 0;&#125; &amp;a表示的是整个数组，&amp;a+1则表示数组a后边的下一个数组，这里它强制转换成(int*)，则百（&amp;a+1）变为4字节，即5后边的四个字节，*（ptr-1）即是 5；*（a+1）这里的a表示的是数组的地址，也是数组首元素的地址，*（a+1）则表示数组的第二个元素即2；运行结果如下： &amp;数组名 和 sizeof（数组名），这里的数组名都表示的是整个数组。 练习2：12345678910111213141516171819struct Test&#123; int Num; char *pcName; short sDate; char cha[2]; short sBa[4];&#125;*p;int main()&#123; printf(&quot;%d\n&quot;, sizeof(*p)); printf(&quot;%p\n&quot;, p+1); printf(&quot;%p\n&quot;, (unsigned long)p + 1); printf(&quot;%p\n&quot;, (unsigned int*)p +1); return 0;&#125; 假设p的值为0x00000这里定义了一个结构体，根据结构体的内存对齐，可以算出这个结构体的大小为20字节，则sizeof（p）为20；p+1即指向下一个结构体，因此它的地址为0x00014;(unsigned long)p这里要特别注意，p本来是指针，这里将它强转为unsigned long这里的p不在是指针，而是一个无符号整数，因此给p加一，即为1；（unsigned int）p这里也对p进行了强制类型转换，p变成了指向无符号整形数的一个指针，对指针加1，即加四个字节，因此这里为0x00004；运行结果如下： 练习3：123456789int main()&#123; int a[4] = &#123;1,2,3,4&#125;; int *ptr1 = (int*)(&amp;a+1); //4 int *ptr2 = (int*)((int)a+1);//2000000 printf(&quot;%x, %x\n&quot;, ptr1[-1],*ptr2);&#125; 这里的&amp;a+1表示下一个数组，然后（int*）进行强制类型转换后，占四字节，ptr1[-1]即*(ptr1-1)表示的是a数组的最后一个元素即4；(int(a)+1),这里有个大坑，它将数组的首元素的第一个字节的地址进行强制转换成整形，+1在转换成整形指针，解引用后是这四个字节的地址。如图： 这里在求值的时候又有一个坑，特别要注意大小端，负责依然无法做对。 运行结果如图： 练习4：1234567891011#include &lt;stdio.h&gt;int main(int argc, char * argv[])&#123; int a[3][2] = &#123;(0,1),(2,3),(4,5)&#125;; int *p; p = a[0]; printf(&quot;%d\n&quot;, p[0]); return 0;&#125; 这里的坑就是一定要注意数组赋值时的逗号表达式。 运行结果如图： 练习5；12345678int main()&#123; int a[5][5]; int(*p)[4]; p = a; printf(&quot;a_ptr=%#p,p_ptr=%#p\n&quot;, &amp;a[4][2],&amp;p[4][2]); printf(&quot;%p,%d\n&quot;, &amp;p[4][2]-&amp;a[4][2], &amp;p[4][2]-&amp;a[4][2]);&#125; 这里的 int(*p)[4]定义了一个数组指针，每个指针指向一个含四个元素的数组，这里的&amp;p[4][2],可以看成(*(p+4)+2);因此指向如图的位置，还有就是%p打印的地址为无符号整形，具体如图所示： 运行结果如图： 练习6：1234567int main()&#123; int aa[2][5] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int *ptr1 = (int*)(&amp;aa+1); int *ptr2 = (int*)(*(aa+1); printf(&quot;%d,%d&quot;,*(ptr-1),*(ptr2-1));&#125; 这里需要注意的是&amp;数组名为整个数组。答案为10，5；运行结果如图： 练习7：123456789int main()&#123; char *a[] = &#123;&quot;work&quot;,&quot;at&quot;,&quot;alibaba&quot;&#125;; char**pa = a; pa++; printf(&quot;%s\n&quot;, *pa); return 0;&#125; *a[]为一个数组指针，pa为一个二级指针，它是数组指针的指针，pa++相当于指向第二个数组指针，解引用则为第二个数组 “at”；运行结果如图： 练习8：1234567891011121314#include &lt;stdio.h&gt;int main()&#123; char *c[] = &#123;&quot;ENTER&quot;,&quot;NEW&quot;,&quot;POINT&quot;,&quot;FIRST&quot;&#125;; char**cp[] = &#123;c+3,c+2,c+1,c&#125;; char***cpp = cp; printf(&quot;%s\n&quot;, **++cp); printf(&quot;%s\n&quot;, *--*++cp+3); printf(&quot;%s\n&quot;, *cpp[-2]+3); printf(&quot;%s\n&quot;, cpp[-1][-1]+1);&#125; 根据代码先画出下图 **++cp里先算++cp，它指向c+2然后解引用指向第三个char*，在解引用就是“POINT”,这里cp现在指向c+2； *–*++cp+3里先运算++cp，在解引用，然后指向c+2，在减减，指向c+3解引用指向第四个char*，然后在+3，则输出ER；这里cp指向c+1，记住借用++cpp之后，减减不在改变cp的值 *cpp[-2]+3可以看成(((cpp-2)))+3,输出ST,这里cpp-2并不改变cpp的值 cpp[-1][-1]+1可以看成(((cpp-1)-1))+1输出EW，这里的cpp依然还指向c+2运行结果如图所示：]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之位操作]]></title>
    <url>%2F2018%2F03%2F24%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E4%BD%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[习题1：编写函数：unsigned int reverse_bit(unsigned int value);这个函数的返回 值value的二进制位模式从左到右翻转后的值。 如：在32位机器上25这个值包含下列各位：00000000000000000000000000011001翻转后：（2550136832）10011000000000000000000000000000程序结果返回：2550136832 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;math.h&gt;unsigned int reserve_bit(unsigned int value)&#123; int a = 0; int sum = 0; int i = 0; for(i=31; i&gt;1; i--) &#123; a = value&amp;1; value = value&gt;&gt;1; sum = sum + a*(int)pow(2, i); &#125; return sum;&#125;int main()&#123; unsigned int num = 25; unsigned int ret = 0; ret = reserve_bit(num); return 0;&#125; 习题2：不使用（a+b）/2这种方式，求两个数的平均值。 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int a = 5; int b = 10; a = a^b; b = a^b; a = a^b; return 0;&#125; 习题3：编程实现：一组数据中只有一个数字出现了一次。其他所有数字都是成对出现的。请找出这个数字。（使用位运算） 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int arr[] = &#123;1,2,3,4,3,2,1&#125;; int size = sizeof(arr)/sizeof(arr[0]); int num = 0; int i = 0; for(i=0; i&lt;size; i++) &#123; num = arr[i]^num; &#125; return 0;&#125; 习题4：有一个字符数组的内容为:”student a am i”,请你将数组的内容改为”i am a student”.要求：不能使用库函数。只能开辟有限个空间（空间个数和字符串的长度无关）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;string.h&gt; #include&lt;assert.h&gt; void reverse(char *start, char *end) &#123; assert(start); assert(end); while (start &lt; end) &#123; char temp = *start; *start = *end; *end = temp; start++; end--; &#125; &#125; void reverse_str(char *str, int sz) &#123; assert(str); //检测传入的字符串 char *str1 = str; char *left = str; char *right = str + sz - 1; reverse(left, right); //先将字符串整体反转 while (*str1) &#123; left = str1; while ((*str1 != &apos;\0&apos;) &amp;&amp; (*str1 != &apos; &apos;)) //找到单词，此处一定要加(*str1 != &apos;\0&apos;)条件限制，因为找到最后一个单词的时候，*str1永远也不为空格 &#123; str1++; &#125; right = str1 - 1; //此时str1指向单词后方的空格，需要减一方能指向单词的最后一个字母 reverse(left, right); //继整体反转后再次反转单词，能使单词拼写顺序恢复过来 if (*str1 == &apos; &apos;) //等于空格让指针后移一位否则不能参与下次循环。 &#123; str1++; &#125; &#125; &#125; int main() &#123; char arr[] = &quot;student a am i&quot;; int sz = strlen(arr); reverse_str(arr, sz); printf(&quot;%s&quot;, arr); getchar(); return 0; &#125;]]></content>
      <categories>
        <category>每日练习</category>
      </categories>
      <tags>
        <tag>位操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的回调函数]]></title>
    <url>%2F2018%2F03%2F22%2FC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1、回调函数回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 具体应用过程基本如下： ⑴定义一个回调函数； ⑵提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者； ⑶当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。 2、qsort的应用123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;search.h&gt;int cmp_char(const void *x, const void *y)&#123; char *_x = (char *)x; char *_y = (char *)y; return *_x &gt; *_y ? 1 : *_x&lt; *_y ? -1 : 0;&#125;int main()&#123; char a[] = &#123;2,23,123,21,5,6,78,9,0,45&#125;; int size = sizeof(a)/sizeof(a[0]); qsort(a , size, sizeof(char), cmp_char); return 0;&#125; 3、my_qsort（利用冒泡排序）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;assert.h&gt;int cmp_int(const void *x, const void *y)&#123; int *_x = (int *)x; int *_y = (int *)y; return *_x &gt; *_y ? 1 : *_x&lt; *_y ? -1 : 0;&#125;void my_swap(void *p, void *q, int size)&#123; int i = 0; char tmp = 0; assert(p); assert(q); for(i=0; i&lt;size; i++) &#123; tmp = *((char*)p+i); *((char*)p+i) = *((char*)q+i); *((char*)q+i) = tmp; &#125;&#125;void my_qsort(void *base, int num, int size, int(*cmp)(void *, void *))&#123; int i = 0; int j = 0; for(i=0; i&lt;num-1 ;i++) &#123; int flag = 1; for(j=0; j&lt;num-1-i; j++) &#123; //自己写的比较函数 if(cmp((char*)base + j*size, (char*)base + (j+1)*size) &gt;0) &#123; my_swap((char*)base + j*size, (char*)base + (j+1)*size, size); flag = 0; &#125; &#125; if(flag) return; &#125;&#125;int main()&#123; int a[] = &#123;1,324,435,7,8,99,4,2,34,123&#125;; int size = sizeof(a)/sizeof(a[0]); my_qsort(a, size, sizeof(int), cmp_int); return 0;&#125;]]></content>
      <categories>
        <category>C语言解析</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解指针和数组]]></title>
    <url>%2F2018%2F03%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1、指针和数组 首先，必须明确指针就是指针，数组就是数组，指针和数组之间没有任何关系。 指针变量在32位系统下，永远占4字节，其值为某一个内存地址。指针可以指向任何地方。 数组的大小和元素的类型和个数有关；定义数组时必须指定其元素的类型和个数；数组可以存任何类型的数据，但不能存函数。指针和数组是完全不一样的东西，只是它们都可以“以指针的形式”或“以下标的形式”进行访问，一个是完全匿名的访问，一个是典型的“具名+匿名”的访问。 2、指针数组和数组指针指针数组：首先它是一个数组，数组的元素都是指针，数组占多少字节由数组本身决定，它是“储存指针的数组”的简称。 数组指针：首先它是一个指针，它指向一个数组。在32为系统下永远占4字节，至于它指向的数组占多少字节并不知道。它是“指向数组的指针”的简称。 这里区分指针数组和数组指针最重要的一点就是看优先级，“[]”的优先级比”*“高，因此p1先和“[]”结合，构成一个数组，数组名为p1，int *饰的是数组的内容，即数组的每个元素，因此int * P[6]是指针数组。又因为“（）”比“[]”优先级高，因此p2先和*结合构成一个指针,指针变量名为p2，int修饰的是数组的内容，即数组的每个元素，p2指向一个包含6个元素的数组，因此它是数组指针。 3、指针和数组的定义、声明1.定义为数组，声明为指针123//main.cchar a[100]; 123//first.cextern char *a; main.c定义了数组，first.c中声明它为指针，这种做法是错误的，main.c和first.c是单独编译的，main.c中，编译器知道a是一个数组，但在first.c中，编译器并不知道这一点，编译器只按照本文件声明的类型来处理，因此虽然a实际大小为100字节，但在first.c中，a只占4字节，这4个字节保存了一个地址，这个地址上存储的是字符型数据。 2.定义为指针，声明为数组123//main.cchar *p = &quot;abcdefg&quot;; 123//first.cextern char p[]; 在main.c中，编译器分配4字节空间，并命名为p，同时p里保存了字符串常量的首字符的首地址，这个字符串常量本身保存在内存的静态区，内容不能更改，而在first.c中，编译器认为p是一个数组，其大小为4字节数组，保存的是char类型的数据，编译器把指针变量p当作一个包含4个char类型数据的数组来使用，指针p的四个之间会被按char类型取出p[0],p[1],p[2],p[3]，如果给p[i]赋值则会把p原来的地址覆盖，导致无法在找到原来的内存。 4、函数指针什么是函数指针？ 函数指针就是函数的指针，它是一个指针，指向函数。 void (*pfun1)(&nbsp;); 这里的pfun1先和*结合，说明pfun1是指针，指针指向一个函数，指向的函数没有参数，并且返回值为void。 来看两个例子理解函数指针 (*&nbsp;(void(&nbsp;*&nbsp;)(&nbsp;)&nbsp;)0&nbsp;)(&nbsp;); void(*)(&nbsp;)，可以看出这是一个函数指针类型，这个函数没有参数，没有返回值 (void(*)(&nbsp;)&nbsp;)0，这里是将0强制转换为函数指针类型，0是一个地址，将这个函数保存在首地址为0的一段区域内的函数。 （*&nbsp;&nbsp;(&nbsp;&nbsp;void(*)&nbsp;&nbsp;(&nbsp;)&nbsp;)0&nbsp;)，这里对保存在首地址为0这一段区域内的函数进行解引用，取出保存在里边的函数。 (&nbsp;*(void(&nbsp;*)(&nbsp;)&nbsp;)&nbsp;0&nbsp;)(&nbsp;)，进行函数的调用。 void(signal(int, void()(int)))(int); void(*&nbsp;)(&nbsp;int)，这是一个函数指针类型，参数为int型，没有返回值 signal&nbsp;(int, void(*)&nbsp;(int)&nbsp;)，signal为一个函数，有两个参数，一个int型的参数，和一个函数指针 void(*signal(&nbsp;int, void(*&nbsp;)(int&nbsp;)&nbsp;)&nbsp;)(&nbsp;int)，signal仍是一个函数，它返回一个函数指针，这个指针指向的函数没有返回值，只有一个int类型的参数。 void(*signal&nbsp;(int, void(*&nbsp;)(int)&nbsp;)&nbsp;)(int);可简化为 tpedef void&nbsp;(*pfun_t)(int); pfun_tsignal&nbsp;(&nbsp;int, pfun_t); 5、指向函数指针数组的指针我们先来看下什么是函数指针数组。把一个函数的地址存到一个数组中，那这个数组就叫函数指针数组。 char&nbsp;&nbsp;(&nbsp;pf[3]&nbsp;)(&nbsp;char *p&nbsp;);这是一个函数指针数组。它是一个数组，数组名为pf，数组内存储了3个指向函数的指针，这些指针指向一些返回值类型为指向字符的指针，参数为一个指向字符的指针的函数。 再下来再看函数指针数组的指针 char &nbsp;*&nbsp;&nbsp;(&nbsp;(&nbsp;pf&nbsp;)&nbsp;[3]&nbsp;)(&nbsp;char *p&nbsp;)这里的pf是一个指针，这个指针指向一个包含了三个元素的数组，这个数组里边存的是指向函数的指针，这些指针指向一些返回值类型为指向字符的指针，参数为一个指向字符的指针的函数。]]></content>
      <categories>
        <category>C语言解析</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用命令安装gcc/g++,gdb]]></title>
    <url>%2F2018%2F03%2F21%2FLinux%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85gcc-g-gdb-vim%2F</url>
    <content type="text"><![CDATA[注意：本博文在Centos6.0版本上进行了测试，不同的版本可能会出现差异以下均为root用户下的操作，安装时请确保你的Linux可以上网 gcc,g++,gdb的用途 gcc用来编译C程序 g++用来编译C++程序， 使用GDB来调试程序 gcc的安装：现在下载的Centos的版本几乎都会自带gcc和vim，所以我们需要的只是g++而已；如果没有请先下载 gcc；检查你的Linux是否有gcc：1which gcc; 如果有就会列出命令的路径，如图： 如果没有使用以下命令安装：1yum install gcc; g++的安装：先检查是否有g++： 1which g++; 如果没有使用以下命令安装：1yum install gcc-c++; gdb的安装：12root用户：yum install gdb普通用户：sudo yum install gdb]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gcc</tag>
        <tag>gdb</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础知识]]></title>
    <url>%2F2018%2F03%2F21%2FLinux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1、Linux文件权限我们先来输入命令：ls -al来查看文件属性。如图： 属性说明： dr-xr-xr-x 22 root root 4096 Mar 17 18:12 . 用户权限 连接数 所有者 用户组 文件大小 修改日期 文件名 文件类型与权限如图： r:表示用户可以查看该目录下的内容，即可以使用“ls”命令w:表示用户可以修改该目录下的内容，包括增加，删除，重命名等x:表示用户可以进入该目录，即可以使用“cd”命令 我们不仅可以用 rwx表示文件的权限，还可以同数字表示：具体如下： r: 4 w: 2 x: 1 每种身份各自的三个权限（r、w、x）分数是需要累加的，例如当权限为[-rwxrwx–],分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others = — = 0+0+0 = 0 所以，该文件的权限数字就是770 2、Linux下的重要目录的含义 目录名 目录的作用 /proc 操作系统运行时，进程信息及内核信息（比如CPU,硬盘分区，内存信息等）存放在这里。/proc目录是伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见/etc/fstab。 /etc 二进制安装包的配置文件默认路径和服务启动命令存放的目录。 /lib 库文件存放目录 /tmp 临时文件目录，有时用户运行程序的时候，会产生临时文件。/tmp就用来存放临时文件的，权限比较特殊。 /bin 常用的二进制命令目录。比如ls cp mkdir 等；和/usr/bin类似。 /usr 这个是系统存放程序的目录，比如命令，帮助文件等。这个目录下有很多的文件和目录。当我们安装一个linux发行版官方提供的软件包时，大多安装在这里。 /var 这个目录的内容是经常变动的，看名字就知道，我们可以理解为vary的缩写，/var下有/var/log这是用来存放系统日志的目录，系统日志路径/var/log/messages。/var/www目录是定义apache服务器站点存放目录;/var/lib用来存放一些库文件，比如mysql的，已经mysql数据库的存放地。 /usr/local 这个目录一般是用来存放用户自编译安装软件的存放目录，一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。相当于C:\Program files /usr/src 内核源码存放目录，比如下面有内核源码目录，比如linux,linux-2.XXX.XX目录等 /usr/lib 和/usr/local/lib 系统会使用到的函数库。 /SElinux SELinux是一种基于域-类型模型(domain-type)的强制访问控制(MAC)安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略。 /sys 虚拟文件系统。和 /proc 目录相似，里面的数据也是保存在内存中的，它主要用来保存内核的相关信息 3、Linux一些重要的命令 du -报告磁盘空间使用情况 -s : 列出总量而已，而不列出每个别的目录占用容量； -a : 列出所有文件与目录容量，，因为默认仅统计目录下面的文件量而已； df -报告文件系统磁盘空间的使用情况 -h : 用常见的格式显示出大小(例如:1K 234M 2G) -i : 用信息索引点代替块表示使用状况 top -可以显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 -i : &lt;时间&gt; 设置间隔时间 -u : &lt;用户名&gt; 指定用户名 -p : &lt;进程号&gt; 指定进程 -b : 批处理 -s : 保密模式 free -命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存 -b : 显示内存的单位为字节 -k : 显示内存的单位为 KB -m : 显示内存的单位为 M -t : 总和信息 su -运行替换用户和组标识的shell -c : 传递单个COMMAND给-c的shell. -f : 传递-f给shell(针对csh或tcsh) -m : 不重置环境变量 sudo -用户也可以通过su切换到root用户运行命令。然而与su的启动一个root shell允许用户运行之后的所有的命令不同，sudo可以针对单个命令授予临时权限。sudo仅在需要时授予用户权限，减少了用户因为错误执行命令损坏系统的可能性。sudo也可以用来以其他用户身份执行命令。此外，sudo可以记录用户执行的命令，以及失败的特权获取。 -s : 以目标用户身份运行 shell – : 停止处理命令行参数 adduser -帐号建立或更新使用者的资讯 password -用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。 -d：删除密码，仅有系统管理者才能使用； -k：设置只有在密码过期失效后，方能更新； -l：锁住密码； -s：列出密码的相关信息，仅有系统管理者才能使用； -u：解开已上锁的帐号 pstack - 显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 work为工作用户，-p为显示进程识别码，ad_preprocess共启动了6个子线程，加上主线程共7个线程。 12345678pstree -p work | grep ad sshd(22669)---bash(22670)---ad_preprocess(4551)-+-&#123;ad_preprocess&#125;(4552) |-&#123;ad_preprocess&#125;(4553) |-&#123;ad_preprocess&#125;(4554) |-&#123;ad_preprocess&#125;(4555) |-&#123;ad_preprocess&#125;(4556) `-&#123;ad_preprocess&#125;(4557)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之字符串函数模拟实现]]></title>
    <url>%2F2018%2F03%2F19%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[习题1：实现strcpy123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void my_strcpy(char* dest,const char* src)&#123; assert(dest); assert(src); while(*src) &#123; *dest++ = *src++; &#125;&#125;int main()&#123; char str[20] = &quot;&quot;; char *src = &quot;fighting&quot;; my_strcpy(str, src); printf(&quot;src: %s\n&quot;, src); printf(&quot;dest: %s\n&quot;, str); return 0;&#125; 习题2：实现strcat1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void my_strcat(char* dest, const char* src)&#123; assert(dest); assert(src); while(*dest) &#123; dest++; if(*dest == &apos;\0&apos;) &#123; while(*src) &#123; *dest++ = *src++; &#125; &#125; &#125;&#125;int main()&#123; char str[20] = &quot;now &quot;; char *src = &quot;fighting&quot;; my_strcat(str, src); printf(&quot;src: %s\n&quot;, src); printf(&quot;dest: %s\n&quot;, str); return 0;&#125; 习题3：模拟实现strstr该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找到s2，则返回空指针。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;assert.h&gt;char *my_strstr(char *str1, char *str2)&#123; char *dest = (char*)str1; char *src = (char*)str2; char *s1 = NULL; assert(str1); assert(str2); if(*str2 == &apos;\0&apos;) return NULL; while(*dest) &#123; s1 = dest; src = (char*)str2; while(*s1 &amp;&amp; *src &amp;&amp; (*s1 == *src)) &#123; s1++; src++; &#125; if(*src == &apos;\0&apos;) &#123; return dest; &#125; dest++; &#125;&#125;int main()&#123; char str[20] = &quot;ab1234esda&quot;; char *src = &quot;1234&quot;; char *ret = NULL; ret = my_strstr(str, src); printf(&quot;%s\n&quot;, ret); return 0;&#125; 习题4：模拟实现strchr该函数字符串中源字符的最后一次出现的位置（末尾空字符也是字符串的一部分，所以在查找范围内）。如果未找到源字符串，则返回空指针。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;assert.h&gt;char *my_strchr(const char *s, char c)&#123; char *p_char = NULL; assert(s); if(s == NULL) &#123; return NULL; &#125; while(*s != &apos;\0&apos;) &#123; if(*s == c) &#123; p_char = (char *)s; &#125; s++; &#125; return p_char;&#125;int main()&#123; char str[20] = &quot;ab1sda1234&quot;; char ch = &apos;\0&apos;; char *ret = NULL; ret = my_strchr(str, ch); printf(&quot;%s\n&quot;, ret); return 0;&#125; 习题5：实现strcmp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;assert.h&gt;int my_strcmp(const char *s1, const char *s2)&#123; int ret = 0; assert(s1); assert(s2); while(*s1 &amp;&amp; *s2) &#123; if(*s1 &gt; *s2) return 1; else if(*s1 &lt; *s2) return -1; s1++; s2++; &#125; return 0;&#125;int main()&#123; char *str1 = &quot;hello&quot;; char *str2 = &quot;hello&quot;; int ret = 0; ret = my_strcmp(str1, str2); if(ret == 0) &#123; printf(&quot;str1 == str2\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;str1在str2后边\n&quot;); &#125; else &#123; printf(&quot;str1在str2前边\n&quot;); &#125; return 0;&#125; 习题6：实现memcpy12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void *my_memcpy(void *dst, const void *src, int n)&#123; void *ret = dst; char *p = (char *)dst; char *q = (char *)src; while(n--) &#123; *p = *q; q++; p++; &#125; return ret;&#125;int main()&#123; char a[10] = &#123;1,2,3,4,5,67&#125;; char b[20]; int i = 0; char * ret = NULL; ret = my_memcpy(b, a, sizeof(a)); for(i=0; i&lt;6; i++) &#123; printf(&quot;%d &quot;, *(ret+i)); &#125; putchar(&apos;\n&apos;); return 0;&#125; 习题7：实现memove12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;void *my_memove(void *dest, const void *src, int size)&#123; void *ret = dest; char *q = dest; char *p = (char*)src; if( p&lt;q &amp;&amp; p+size&gt;q ) &#123; q = q + size -1; p = p + size -1; while(size--) &#123; *q = *p; q--; p--; &#125; &#125; else &#123; while(size--) &#123; *q = *p; q++; p++; &#125; &#125; return ret;&#125;int main()&#123; char a[15] = &quot;abcde&quot;; char b[15] = &quot;&quot;; char *ret = NULL; ret = my_memove(b, a, sizeof(a)); printf(&quot;%s\n&quot;, ret); return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[main函数参数]]></title>
    <url>%2F2018%2F03%2F19%2Fmain%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[习题1: main函数的参数 argc: 是个整型变量，表示命令行参数的个数（含第一个参数） argv: 是个字符指针的数组，每个元素是一个字符指针，指向一个字符串。这些字符串就是命令行中的每一个参数（字符串）。 envc: 是字符指针数组， 数组的每一个原元素是一个指向一个环境变量（字符串）的字符指针。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[], char* envp[])&#123; float a = (float)atoi(argv[2]); float b = (float)atoi(argv[3]); float res = 0; if( strcmp(&quot;-a&quot;, argv[1]) == 0) &#123; res = a + b; &#125; else if(strcmp(&quot;-s&quot;, argv[1]) == 0) &#123; res = a - b; &#125; else if(strcmp(&quot;-m&quot;, argv[1]) == 0) &#123; res = a * b; &#125; else if(strcmp(&quot;-d&quot;, argv[1]) == 0) &#123; res = a/b; &#125; else &#123; ; &#125; printf(&quot;res: %.3f \n&quot;, res); return 0;&#125; 习题2：排序字符串写冒泡排序可以排序多个字符串 //思路同冒泡排序，定义一个指针数组。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void bubble_sort_string(char* str[], int size) &#123; int i = 0; int j = 0; char *tmp = NULL; for(i=0; i&lt;size-1; i++) &#123; for(j=0; j&lt;size-1-i; j++) &#123; if (strcmp(*(str + j), *(str + j + 1))&gt;0) &#123; tmp = *(str+j); *(str + j) = *(str + j + 1); *(str + j + 1) = tmp; &#125; &#125; &#125;&#125;int main()&#123; char *str[] = &#123;&quot;fgjaa&quot;, &quot;basdb&quot;, &quot;aada&quot;&#125;; //定义一个数组指针 int size = sizeof(str)/sizeof(*str); int i = 0; bubble_sort_string(str, size); for(i=0; i&lt;size; i++) &#123; printf(&quot;%s\n&quot;, *(str+i)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>main函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[习题1：查找数字一个数组中只有两个数字是出现一次，其他所有数字都出现了两次。 找出这两个数字，编程实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;//利用桶排序实现int main()&#123; int arr[] = &#123;5,2,7,4,6,6,7,8,5,4&#125;; int arr2[100] = &#123;0&#125;; int i = 0; int t = 0; int size = sizeof(arr) / sizeof(arr[0]); for(i=0; i&lt;size; i++) &#123; t = arr[i]; arr2[t]++; &#125; for(i=0; i&lt;100; i++) &#123; if(arr2[i] == 1) &#123; printf(&quot;%d &quot;, i); &#125; &#125; putchar(&apos;\n&apos;); return 0;&#125;//查找法int main()&#123; int arr[] = &#123;5,2,7,4,6,6,7,8,5,4&#125;; int size = sizeof(arr) / sizeof(arr[0]); int i = 0; int j = 0; for(i=0; i&lt;size-1; i++) &#123; for(j=0; j&lt;size; j++) &#123; if(i == j) ; else if(arr[i] == arr[j]) break; &#125; if(j == size) printf(&quot;%d &quot;, arr[i]); &#125; putchar(&apos;\n&apos;); return 0;&#125; 习题2：喝汽水喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，给20元，可以多少汽水。编程实现。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int money = 0; int total = 0; scanf(&quot;%d&quot;, &amp;money); total = money; while( money &gt; 1 ) &#123; total += money/2; money = money/2; &#125; printf(&quot;可以喝%d瓶。\n&quot;, total); return 0;&#125; 习题3：strcpy模拟实现strcpy 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void my_strcpy(char* str, const char * src)&#123; assert(str); assert(src); while(*src) &#123; *str++=*src++; &#125;&#125;int main()&#123; char str[20] = &quot;&quot;; char *src = &quot;Hello bit.&quot;; my_strcpy(str, src); printf(&quot;src:%s\n&quot;, src); printf(&quot;dest:%s\n&quot;, str); return 0;&#125; 另注：在使用strcpy是目的字符串不可用指针定义， 习题4：strcat模拟实现strcat 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void my_strcat(char * dest,const char* src)&#123; assert(dest); assert(src); while(*dest) &#123; dest++; &#125; while(*src) &#123; *dest++ = *src++; &#125;&#125;int main()&#123; char str[20] = &quot;Hello &quot;; char *src = &quot;bit.&quot;; my_strcat(str, src); printf(&quot;%s\n&quot;, str); return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之可变参数]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[习题1：求平均值使用可变参数，实现函数，求函数参数的平均值。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;float average(int n_values, ...)&#123; va_list var_arg; int count = 0; float sum = 0; //准备访问可变参数 va_start( var_arg, n_values ); //添加取自可变参数列表的值 for( count = 0; count &lt; n_values; count +=1 ) &#123; sum += va_arg( var_arg, int ); &#125; //完成处理可变参数 va_end( var_arg ); return sum/n_values;&#125;int main()&#123; int n_values = 0; int v1 = 2; int v2 = 3; int v3 = 5;int v4 = 10; float argl = 0; float argl2 = 0; argl = average(3, v1, v2, v3); argl2 = average(4, v1, v2, v3, v4); printf(&quot;argl = %f, argl2 = %f\n&quot;, argl, argl2); return 0;&#125; 习题2： 求最大值使用可变参数，实现函数，求函数参数的最大值。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int Max(int n_values, ...)&#123; va_list va_arg; int count = 0; int tmp = 0; int max = 0; va_start( va_arg, n_values); for(count=0; count&lt;n_values; count++) &#123; if( (tmp =va_arg(va_arg, int))&gt; max ) &#123; max = tmp; &#125; &#125; return max;&#125;int main()&#123; int n_values = 0; int v1 = 2; int v2 = 3; int v3 = 5;int v4 = 10; int max1 = 0; int max2 = 0; max1 = Max(3, v1, v2, v3); max2 = Max(4, v1, v2, v3, v4); printf(&quot;max1 = %d, max2 = %d\n&quot;, max1, max2); return 0;&#125; 习题3： 模拟printf模拟实现printf函数，可完成下面的功能 能完成下面函数的调用。 print(“s ccc d.\n”,”hello”,’b’,’i’,’t’，100); 函数原型：print(char *format, …) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;stdarg.h&gt;void my_print(char *format, ...)&#123; va_list va_arg; char *pstr = NULL; char ch = 0; int num = 0; assert(format); va_start(va_arg, format); while(*format) &#123; if(*format == &apos;%&apos;) &#123; format++; switch(*format) &#123; case &apos;s&apos;: pstr = va_arg(va_arg, char*); while(*pstr) &#123; putchar(*pstr); pstr++; &#125; break; case &apos;c&apos;: ch = va_arg(va_arg, char); putchar(ch); break; case &apos;d&apos;: num = va_arg(va_arg, char); putchar(num); break; default: putchar(*format-1); putchar(*format); &#125; &#125; else &#123; putchar(*format); format++; &#125; &#125; va_end( va_arg );&#125;int main()&#123; my_print(&quot;%s%s%c%c%c%d&quot;,&quot;s ccc d.\n&quot;,&quot;hello&quot;,&apos;b&apos;,&apos;i&apos;,&apos;t&apos;,100); putchar(&apos;\n&apos;); return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>可变参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数列表]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[测试环境： vs2008 1、可变参数列表 为什么需要可变参数呢？ 在函数原型中，列出了函数期望接受的参数，原型只能显示固定数目的参数，如果函数原型列出的参数与可调用参数不匹配或数目不一样，程序将无法运行。例如，我们想要求一系列值的平均值，这里的一系列的数目是不确定的，如果这些值存储于数组中，这个任务就很简单了，但如果我们不用数组，想要直接调用，就需要可变参数了。 什么是可变参数？ C语言中的可变参数是通过将函数是按为可变参数的形式，可以是得函数接受一个以上的任意多个参数（不固定）。 2、stdarg宏 可变参数列表是通过宏来是实现的，这些宏定义于 stdarg.h 有文件，这个有文件声明了三个宏———— va_start, va_arg和va_end,和一个类型 va_list。1234567#elif defined(_M_IX86)#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )#define _crt_va_start(ap,v) ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )#define _crt_va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )#define _crt_va_end(ap) ( ap = (va_list)0 ) 3、可变参数三个宏的使用初始化 函数声明了一个名叫 va_arg 的变量， 它用于访问未确定的部分，这个变量通过 va_start 来初始化。 它的里边有两个参数： 1、va_list变量的名字 2、省略号前最后一个有名字的参数。 初始化时把va_arg变量设置为可变参数部分的第一个参数。 访问后边参数 这里需要 va_arg ，va_arg返回这个参数的值，并使用 va_arg指向下一个可变参数。 它的里边也有两个参数： 1、va_list变量 2、参数列表中下一个参数的类型 用va_end宏来释放此前动态分配的内存4、看一个例子接下来我们来看一个例子来理解下可变参数的用法。 12345678910111213141516171819202122232425262728293031323334353637//求任意个参数的平均值#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int Max(int n_values, ...)&#123; va_list va_arg; int count = 0; int tmp = 0; int max = 0; va_start( va_arg, n_values); //初始化 for(count=0; count&lt;n_values; count++) &#123; if( (tmp =va_arg(va_arg, int))&gt; max ) //添加取自可变参数列表的值 &#123; max = tmp; &#125; &#125; return max;&#125;int main()&#123; int n_values = 0; int v1 = 2; int v2 = 3; int v3 = 5;int v4 = 10; int max1 = 0; int max2 = 0; max1 = Max(3, v1, v2, v3); max2 = Max(4, v1, v2, v3, v4); printf(&quot;max1 = %d, max2 = %d\n&quot;, max1, max2); return 0;&#125; 5、可变参数的限制 可变参数必须从头到尾逐个访问，如果你在访问了几个可变参数之后想半途终止，这是可以的，但是，如果你想一开始就访问列表中间的参数，那是不行的。 参数列表中至少有一个命名参数。如果连一个命名参数都没有，就无法使用va_start 这些宏是无法直接判断实际存在参数的变量。 这些宏无法判断每个参数的是类型。 如果在 va_arg 中指定了错误的类型，那么其后果是不可预测的。 可变参数的创建是先开辟一块空间，创建好最右边的变量之后，然后在根据类别有上往下创建，因此不能直接访问中间变量，可以访问一半终止。]]></content>
      <categories>
        <category>C语言解析</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>可变参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之递归]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[习题1：斐波那契数递归和非递归分别实现求第n个斐波那契数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;//斐波那契数，非递归/*int fibo(int num)&#123; int arr[4] = &#123; 0, 1, 1&#125;; int i = 0; if(num&lt;=2) &#123; return 1; &#125; for(i=3; i&lt;=num; i++) &#123; arr[3] = arr[2] + arr[1]; arr[1] = arr[2]; arr[2] = arr[3]; &#125; return arr[3];&#125;*///递归int fibo(int num)&#123; if( num &lt;= 2 ) &#123; return 1; &#125; return fibo(num-1)+fibo(num-2);&#125;int main()&#123; int num = 0; int ret = 0; do&#123; printf(&quot;Enter: 1-45\n&quot;); scanf(&quot;%d&quot;, &amp;num); &#125;while(num&lt;0 || num&gt;=45); ret = fibo(num); printf(&quot;第%d个fibo数为：%d\n&quot;, num, ret); return 0;&#125; 习题2：n^k编写一个函数实现n^k，使用递归实现 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int my_power(int n, int k)&#123; if(k == 1) &#123; return n; &#125; if(k == 0) &#123; return 1; &#125; return my_power(n, k-1)*n;&#125;int main()&#123; int n = 0; int k = 0; int ret = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ret = my_power(n, k); printf(&quot;%d^%d = %d\n&quot;, n, k, ret); return 0;&#125; 习题3：DigitSum(n)写一个递归函数DigitSum(n)，输入一个非负整数，返回组成它的数字之和，例如，调用DigitSum(1729)，则应该返回1+7+2+9，它的和是19 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int DigitSum(int n)&#123; if(n&lt;10) return n; return DigitSum(n/10)+(n%10);&#125;int main()&#123; int num = 0; int ret = 0; do&#123; printf(&quot;Enter: &gt;0.\n&quot;); scanf(&quot;%d&quot;, &amp;num); &#125;while(num &lt;= 0); ret = DigitSum(num); printf(&quot;%d\n&quot;, ret); return 0;&#125; 习题4：字符反向排列编写一个函数reverse_string(char * string)（递归实现）实现：将参数字符串中的字符反向排列。要求：不能使用C函数库中的字符串操作函数。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void reverse_string(char * str)&#123; assert(str); if(*str != &apos;\0&apos;) &#123; str++; reverse_string(str); printf(&quot;%c&quot;, *(str-1)); &#125;&#125;int main()&#123; char arr[] = &quot;Hello everybody&quot;; reverse_string(arr); putchar(&apos;\n&apos;); return 0;&#125; 习题5：strlen递归和非递归分别实现strlen 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;assert.h&gt;int my_strlen(const char * str)&#123; assert(str); if(!*str) return 0; else return 1 + my_strlen(str+1);&#125;//非递归/*int my_strlen(const char * str)&#123; int count = 0; assert(str); while(*str != &apos;\0&apos;) //开始又忘记解引用了，迷醉 &#123; str++; count++; &#125; return count;&#125;*/int main()&#123; char arr[] = &quot;abcsdf&quot;; int ret = 0; ret = my_strlen(arr); printf(&quot;%d\n&quot;, ret); return 0;&#125; 习题6：n的阶乘递归和非递归分别实现求n的阶乘 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;assert.h&gt;//非递归/*int jiecheng(int n)&#123; int i = 0; int sum = 1; for(i=1; i&lt;=n; i++) &#123; sum *= i; &#125; return sum;&#125;*/int jiecheng(int n)&#123; if(n == 1) return 1; return n*jiecheng(n-1);&#125;int main()&#123; int n = 0; int ret = 0; scanf(&quot;%d&quot;, &amp;n); ret = jiecheng(n); printf(&quot;%d! = %d\n&quot;, n, ret); return 0;&#125; 习题7：打印一个整数的每一位递归方式实现打印一个整数的每一位 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void my_print(int num)&#123; if(num &lt;10) &#123; printf(&quot;%d &quot;, num); &#125; else &#123; my_print(num/10); printf(&quot;%d &quot;, num%10); &#125; &#125;int main()&#123; int num = 0; scanf(&quot;%d&quot;, &amp;num); my_print(num); return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之栈帧]]></title>
    <url>%2F2018%2F03%2F15%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[习题1：旋转字符实现一个函数，可以左旋字符串中的k个字符。ABCD左旋一个字符得到BCDAABCD左旋两个字符得到CDAB 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void zuoxuan(char *str, int num)&#123; char tmp; char *dst = str; assert(str); while(num) &#123; str = dst; tmp = *str; while(*(str+1)) &#123; *str = *(str+1); str++; &#125; *str = tmp; num--; &#125;&#125;int main()&#123; char ch[15] = &quot; &quot;; int num = 0; scanf(&quot;%d&quot;, &amp;num); //获取左旋的个数 scanf(&quot;%s&quot;, ch); //获取字符串 zuoxuan(ch, num); printf(&quot;%s\n&quot;, ch); return 0;&#125; 在写程序中遇到的问题：把指针没有解引用，一直对指针做运算，程序没有输出结果，发现是没有解引用。 习题2: 是否是旋转得到判断一个字符串是否为另外一个字符串旋转之后的字符串。例如：给定s1 ＝ AABCD和s2 = BCDAA，返回1，给定s1=abcd和s2=ACBD，返回0. AABCD左旋一个字符得到ABCDAAABCD左旋两个字符得到BCDAA AABCD右旋一个字符得到DAABC 理解：这个题目和第一个题目类似，上边的字符串右旋一个字符就相当于左旋两个字符。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;int judge(char *str1, char *str2, int size) //代码的缺点是在翻转时改变了原来的字符串&#123; char tmp; char *dst = str1; assert(str1); assert(str2); while(size) &#123; str1 = dst; if(strcmp(str1,str2) == 0) return 1; tmp = *str1; while(*(str1+1)) &#123; *str1 = *(str1+1); str1++; &#125; *str1 = tmp; size--; &#125; return 0;&#125;int main()&#123; char s1[] = &quot;ABCDEF&quot;; //源字符串 char s2[] = &quot;DEFABC&quot;; //要判断的字符串 int ret = 0; int size = strlen(s1); ret = judge(s1, s2, size); if(ret == 0) &#123; printf(&quot;No.\n&quot;); &#125; else &#123; printf(&quot;Yes.\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈帧与函数的调用]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[测试环境: vc2008 1、什么是栈 在计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop）,但栈这个容器必须遵守一条规则：先入栈的数据后出栈，多多少少像叠起来的一叠书，先叠上去的书在最下面，因此最后才能取出。 程序栈的简图 这里的ebp表示栈低寄器，esp表示栈顶寄存器，在栈上压入数据会导致esp减少，弹出数据会使得esp增大。相反，直接减小esp的值相当于开辟空间，增大esp的值相当于回收空间。 2、一个很常见的活动记录 活动记录 3、我们来看一个看例子 接下来，我们用一个简单的程序来说明函数的调用以及栈的布局 1234567891011121314151617181920#include &lt;stdio.h&gt;int fun(int a, int b)&#123; int z = a + b; return z;&#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c = fun(a, b); printf(&quot;c = %d&quot;, c); return 0;&#125; 这里我们直接进行调试，通过汇编代码能看的更去清楚。我们先从main函数开始 这里需要强调的是call命令，它有两个作用： 把当前指令的下一条指令的地址压入栈中 跳转到函数体执行到这里可能有人会想，cpu怎么知道我这会执行到那条代码，它是怎样计算的呢，在这里我们还需要知道一个寄存器，EIP寄存器（也叫程序计数器），它总是指向当前指令的下一条指令的地址。下来我们进入fun函数体 这样我就进入到了fun函数内部，当fun函数执行完时，执行123011013DD mov esp,ebp 011013DF pop ebp 011013E0 ret 使esp=ebp； 然后让 old ebp出栈，至此ebp就回到了main函数的ebp，ret从栈中去出返回地址，并跳到此处。101101429 add esp,8 紧接着又执行了这句，使esp指向main函数的栈顶。 fun函数的这段汇编代码基本分为下面几步：1.保存edp，让edp指向目前的栈顶1200E913B0 push ebp 00E913B1 mov ebp,esp 2.在栈上开辟一块空间100E913B3 sub esp,0CCh 3.保存ebx，esi，edi寄存器12300E913B9 push ebx 00E913BA push esi 00E913BB push edi 4.加入调试信息123400E913BC lea edi,[ebp-0CCh] 00E913C2 mov ecx,33h 00E913C7 mov eax,0CCCCCCCCh 00E913CC rep stos dword ptr es:[edi] 5.返回z，在这里是返回值通过eax寄存器传回100E913D7 mov eax,dword ptr [z] 6.从栈上恢复edi，esi，ebx寄存器12300E913DA pop edi 00E913DB pop esi 00E913DC pop ebx 7.恢复进入函数前的esp和edp1200E913DD mov esp,ebp 00E913DF pop ebp 8.使用ret指令返回100E913E0 ret 特别注意：main函数也是一个被调函数，因此调用它的过程和调用fun函数基本类似 4、通过栈帧修改ret返回的地址这里我们调用fun函数后，不让ret返回到main函数，而是修改它的地址，让他来到bug函数，将栈中存的返回地址保存到全局变量ret中，执行完bug函数后，让函数在返回main函数测试环境为vc6.0 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 执行结果如图： 但是一按回车就会出错，原因是call命令会把当前命令的下一条指令的地址压入栈中，执行完后会跳转到函数体。但是我们调用BUG函数时没有通过call命令调用，因此，我们少push一次，按回车后的esp应该指向的是main-esp-4；因此我们需要在main函数里调用完fun函数后将esp+4，保持栈帧平衡， 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); __asm &#123; sub esp, 4; &#125; printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 执行结果如图：]]></content>
      <categories>
        <category>C语言解析</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>C语言</tag>
        <tag>栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018目标]]></title>
    <url>%2F2018%2F03%2F05%2F2018%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;今天是开学的第一天，大三的第二学期，再过半年就面临找工作了，由于自己想要找IT方面的工作，因此要付出更多的努力，今后一定不能浪费时间， 蓝桥杯&ensp;&ensp;&ensp;现在是3/15，距离蓝桥杯开始还有25天，我还没有做准备，今天晚上看了看题，很慌张，自己的C语言水平是如此的低，因此在这25天里，重点突击蓝桥杯，多做题，多思考，争取取得好成绩。 四级&ensp;&ensp;&ensp;从大一到现在已经考了三次四级，这次总算过了校线，前两次因为自己的英语差，以及裸考成绩都不如人意，这学期也将四级最为重点，争取在6月份考过四级，期待七月份的好成绩。 C++&ensp;&ensp;&ensp;从上学期十二月份开始，自己将方向定为C++，因为不喜欢本专业，也不考研，因此转向IT，之前学过C语言，搞过单片机，因为单片机对C语言的要求不高，因此我的C语言水平也比较差。从这学期开始，好好学习计算机类课程，提高自己的实力，争取在秋招找到一份好工作。 博客&ensp;&ensp;&ensp;定时的更新博客，每周至少写两篇技术博客，算是对自己学习的督促，和对知识的总结吧。 2018加油！ &ensp;&ensp;&ensp;&ensp;&ensp;fighting！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my blog 搭建完成]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[搭建博客一直都想有一个自己的博客，今使用 GitHub 时看见 GitHub+Hexo 也可以搭建静态博客，便产生了搭建博客的想法，于是便开始着手搭建。本博客于2018/3/1开始搭建，于2018/3/3基本搭建完成，后期继续优化。 搭建博客的目的用于写技术博客，也用于记录生活,后期会持续的定时更新博客。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.3.1]]></title>
    <url>%2F2018%2F03%2F01%2F2018-3-1%2F</url>
    <content type="text"><![CDATA[要狠心，要改过自新，要向前看，要赢。]]></content>
  </entry>
</search>
