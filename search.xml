<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F18%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[title: 每日练习date: 2018-03-18 18:48:14tags: [数组,字符串]categories: C语言练习 习题1：查找数字一个数组中只有两个数字是出现一次，其他所有数字都出现了两次。找出这两个数字，编程实现。 #include &lt;stdio.h&gt; //利用桶排序实现 int main() { int arr[] = {5,2,7,4,6,6,7,8,5,4}; int arr2[100] = {0}; int i = 0; int t = 0; int size = sizeof(arr) / sizeof(arr[0]); for(i=0; i&lt;size; i++) { t = arr[i]; arr2[t]++; } for(i=0; i&lt;100; i++) { if(arr2[i] == 1) { printf(&quot;%d &quot;, i); } } putchar(&apos;\n&apos;); return 0; } //查找法 int main() { int arr[] = {5,2,7,4,6,6,7,8,5,4}; int size = sizeof(arr) / sizeof(arr[0]); int i = 0; int j = 0; for(i=0; i&lt;size-1; i++) { for(j=0; j&lt;size; j++) { if(i == j) ; else if(arr[i] == arr[j]) break; } if(j == size) printf(&quot;%d &quot;, arr[i]); } putchar(&apos;\n&apos;); return 0; } 习题2：喝汽水喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，给20元，可以多少汽水。编程实现。 #include &lt;stdio.h&gt; int main() { int money = 0; int total = 0; scanf(&quot;%d&quot;, &amp;money); total = money; while( money &gt; 1 ) { total += money/2; money = money/2; } printf(&quot;可以喝%d瓶。\n&quot;, total); return 0; } 习题3：strcpy模拟实现strcpy #include &lt;stdio.h&gt; #include &lt;assert.h&gt; void my_strcpy(char* str, const char * src) { assert(str); assert(src); while(*src) { *str++=*src++; } } int main() { char str[20] = &quot;&quot;; char *src = &quot;Hello bit.&quot;; my_strcpy(str, src); printf(&quot;src:%s\n&quot;, src); printf(&quot;dest:%s\n&quot;, str); return 0; } 另注：在使用strcpy是目的字符串不可用指针定义， 习题4：strcat模拟实现strcat #include &lt;stdio.h&gt; #include &lt;assert.h&gt; void my_strcat(char * dest,const char* src) { assert(dest); assert(src); while(*dest) { dest++; } while(*src) { *dest++ = *src++; } } int main() { char str[20] = &quot;Hello &quot;; char *src = &quot;bit.&quot;; my_strcat(str, src); printf(&quot;%s\n&quot;, str); return 0; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[每日练习之可变参数]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[习题1：求平均值使用可变参数，实现函数，求函数参数的平均值。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;float average(int n_values, ...)&#123; va_list var_arg; int count = 0; float sum = 0; //准备访问可变参数 va_start( var_arg, n_values ); //添加取自可变参数列表的值 for( count = 0; count &lt; n_values; count +=1 ) &#123; sum += va_arg( var_arg, int ); &#125; //完成处理可变参数 va_end( var_arg ); return sum/n_values;&#125;int main()&#123; int n_values = 0; int v1 = 2; int v2 = 3; int v3 = 5;int v4 = 10; float argl = 0; float argl2 = 0; argl = average(3, v1, v2, v3); argl2 = average(4, v1, v2, v3, v4); printf(&quot;argl = %f, argl2 = %f\n&quot;, argl, argl2); return 0;&#125; 习题2： 求最大值使用可变参数，实现函数，求函数参数的最大值。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int Max(int n_values, ...)&#123; va_list va_arg; int count = 0; int tmp = 0; int max = 0; va_start( va_arg, n_values); for(count=0; count&lt;n_values; count++) &#123; if( (tmp =va_arg(va_arg, int))&gt; max ) &#123; max = tmp; &#125; &#125; return max;&#125;int main()&#123; int n_values = 0; int v1 = 2; int v2 = 3; int v3 = 5;int v4 = 10; int max1 = 0; int max2 = 0; max1 = Max(3, v1, v2, v3); max2 = Max(4, v1, v2, v3, v4); printf(&quot;max1 = %d, max2 = %d\n&quot;, max1, max2); return 0;&#125; 习题3： 模拟printf模拟实现printf函数，可完成下面的功能 能完成下面函数的调用。 print(“s ccc d.\n”,”hello”,’b’,’i’,’t’，100); 函数原型：print(char *format, …) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;stdarg.h&gt;void my_print(char *format, ...)&#123; va_list va_arg; char *pstr = NULL; char ch = 0; int num = 0; assert(format); va_start(va_arg, format); while(*format) &#123; if(*format == &apos;%&apos;) &#123; format++; switch(*format) &#123; case &apos;s&apos;: pstr = va_arg(va_arg, char*); while(*pstr) &#123; putchar(*pstr); pstr++; &#125; break; case &apos;c&apos;: ch = va_arg(va_arg, char); putchar(ch); break; case &apos;d&apos;: num = va_arg(va_arg, char); putchar(num); break; default: putchar(*format-1); putchar(*format); &#125; &#125; else &#123; putchar(*format); format++; &#125; &#125; va_end( va_arg );&#125;int main()&#123; my_print(&quot;%s%s%c%c%c%d&quot;,&quot;s ccc d.\n&quot;,&quot;hello&quot;,&apos;b&apos;,&apos;i&apos;,&apos;t&apos;,100); putchar(&apos;\n&apos;); return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>可变参数</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数列表]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[测试环境： vs2008 1、可变参数列表 为什么需要可变参数呢？ 在函数原型中，列出了函数期望接受的参数，原型只能显示固定数目的参数，如果函数原型列出的参数与可调用参数不匹配或数目不一样，程序将无法运行。例如，我们想要求一系列值的平均值，这里的一系列的数目是不确定的，如果这些值存储于数组中，这个任务就很简单了，但如果我们不用数组，想要直接调用，就需要可变参数了。 什么是可变参数？ C语言中的可变参数是通过将函数是按为可变参数的形式，可以是得函数接受一个以上的任意多个参数（不固定）。 2、stdarg宏 可变参数列表是通过宏来是实现的，这些宏定义于 stdarg.h 有文件，这个有文件声明了三个宏———— va_start, va_arg和va_end,和一个类型 va_list。1234567#elif defined(_M_IX86)#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )#define _crt_va_start(ap,v) ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )#define _crt_va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )#define _crt_va_end(ap) ( ap = (va_list)0 ) 3、可变参数三个宏的使用初始化 函数声明了一个名叫 va_arg 的变量， 它用于访问未确定的部分，这个变量通过 va_start 来初始化。 它的里边有两个参数： 1、va_list变量的名字 2、省略号前最后一个有名字的参数。 初始化时把va_arg变量设置为可变参数部分的第一个参数。 访问后边参数 这里需要 va_arg ，va_arg返回这个参数的值，并使用 va_arg指向下一个可变参数。 它的里边也有两个参数： 1、va_list变量 2、参数列表中下一个参数的类型 用va_end宏来释放此前动态分配的内存4、看一个例子接下来我们来看一个例子来理解下可变参数的用法。 12345678910111213141516171819202122232425262728293031323334353637//求任意个参数的平均值#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int Max(int n_values, ...)&#123; va_list va_arg; int count = 0; int tmp = 0; int max = 0; va_start( va_arg, n_values); //初始化 for(count=0; count&lt;n_values; count++) &#123; if( (tmp =va_arg(va_arg, int))&gt; max ) //添加取自可变参数列表的值 &#123; max = tmp; &#125; &#125; return max;&#125;int main()&#123; int n_values = 0; int v1 = 2; int v2 = 3; int v3 = 5;int v4 = 10; int max1 = 0; int max2 = 0; max1 = Max(3, v1, v2, v3); max2 = Max(4, v1, v2, v3, v4); printf(&quot;max1 = %d, max2 = %d\n&quot;, max1, max2); return 0;&#125; 5、可变参数的限制 可变参数必须从头到尾逐个访问，如果你在访问了几个可变参数之后想半途终止，这是可以的，但是，如果你想一开始就访问列表中间的参数，那是不行的。 参数列表中至少有一个命名参数。如果连一个命名参数都没有，就无法使用va_start 这些宏是无法直接判断实际存在参数的变量。 这些宏无法判断每个参数的是类型。 如果在 va_arg 中指定了错误的类型，那么其后果是不可预测的。 可变参数的创建是先开辟一块空间，创建好最右边的变量之后，然后在根据类别有上往下创建，因此不能直接访问中间变量，可以访问一半终止。]]></content>
      <categories>
        <category>c语言常见问题解析</category>
      </categories>
      <tags>
        <tag>可变参数</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之递归]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[习题1：斐波那契数递归和非递归分别实现求第n个斐波那契数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;//斐波那契数，非递归/*int fibo(int num)&#123; int arr[4] = &#123; 0, 1, 1&#125;; int i = 0; if(num&lt;=2) &#123; return 1; &#125; for(i=3; i&lt;=num; i++) &#123; arr[3] = arr[2] + arr[1]; arr[1] = arr[2]; arr[2] = arr[3]; &#125; return arr[3];&#125;*///递归int fibo(int num)&#123; if( num &lt;= 2 ) &#123; return 1; &#125; return fibo(num-1)+fibo(num-2);&#125;int main()&#123; int num = 0; int ret = 0; do&#123; printf(&quot;Enter: 1-45\n&quot;); scanf(&quot;%d&quot;, &amp;num); &#125;while(num&lt;0 || num&gt;=45); ret = fibo(num); printf(&quot;第%d个fibo数为：%d\n&quot;, num, ret); return 0;&#125; 习题2：n^k编写一个函数实现n^k，使用递归实现 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int my_power(int n, int k)&#123; if(k == 1) &#123; return n; &#125; if(k == 0) &#123; return 1; &#125; return my_power(n, k-1)*n;&#125;int main()&#123; int n = 0; int k = 0; int ret = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ret = my_power(n, k); printf(&quot;%d^%d = %d\n&quot;, n, k, ret); return 0;&#125; 习题3：DigitSum(n)写一个递归函数DigitSum(n)，输入一个非负整数，返回组成它的数字之和，例如，调用DigitSum(1729)，则应该返回1+7+2+9，它的和是19 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int DigitSum(int n)&#123; if(n&lt;10) return n; return DigitSum(n/10)+(n%10);&#125;int main()&#123; int num = 0; int ret = 0; do&#123; printf(&quot;Enter: &gt;0.\n&quot;); scanf(&quot;%d&quot;, &amp;num); &#125;while(num &lt;= 0); ret = DigitSum(num); printf(&quot;%d\n&quot;, ret); return 0;&#125; 习题4：字符反向排列编写一个函数reverse_string(char * string)（递归实现）实现：将参数字符串中的字符反向排列。要求：不能使用C函数库中的字符串操作函数。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void reverse_string(char * str)&#123; assert(str); if(*str != &apos;\0&apos;) &#123; str++; reverse_string(str); printf(&quot;%c&quot;, *(str-1)); &#125;&#125;int main()&#123; char arr[] = &quot;Hello everybody&quot;; reverse_string(arr); putchar(&apos;\n&apos;); return 0;&#125; 习题5：strlen递归和非递归分别实现strlen 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;assert.h&gt;int my_strlen(const char * str)&#123; assert(str); if(!*str) return 0; else return 1 + my_strlen(str+1);&#125;//非递归/*int my_strlen(const char * str)&#123; int count = 0; assert(str); while(*str != &apos;\0&apos;) //开始又忘记解引用了，迷醉 &#123; str++; count++; &#125; return count;&#125;*/int main()&#123; char arr[] = &quot;abcsdf&quot;; int ret = 0; ret = my_strlen(arr); printf(&quot;%d\n&quot;, ret); return 0;&#125; 习题6：n的阶乘递归和非递归分别实现求n的阶乘 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;assert.h&gt;//非递归/*int jiecheng(int n)&#123; int i = 0; int sum = 1; for(i=1; i&lt;=n; i++) &#123; sum *= i; &#125; return sum;&#125;*/int jiecheng(int n)&#123; if(n == 1) return 1; return n*jiecheng(n-1);&#125;int main()&#123; int n = 0; int ret = 0; scanf(&quot;%d&quot;, &amp;n); ret = jiecheng(n); printf(&quot;%d! = %d\n&quot;, n, ret); return 0;&#125; 习题7：打印一个整数的每一位递归方式实现打印一个整数的每一位 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void my_print(int num)&#123; if(num &lt;10) &#123; printf(&quot;%d &quot;, num); &#125; else &#123; my_print(num/10); printf(&quot;%d &quot;, num%10); &#125; &#125;int main()&#123; int num = 0; scanf(&quot;%d&quot;, &amp;num); my_print(num); return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日练习之栈帧]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%E4%B9%8B%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[习题1：旋转字符实现一个函数，可以左旋字符串中的k个字符。ABCD左旋一个字符得到BCDAABCD左旋两个字符得到CDAB 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void zuoxuan(char *str, int num)&#123; char tmp; char *dst = str; assert(str); while(num) &#123; str = dst; tmp = *str; while(*(str+1)) &#123; *str = *(str+1); str++; &#125; *str = tmp; num--; &#125;&#125;int main()&#123; char ch[15] = &quot; &quot;; int num = 0; scanf(&quot;%d&quot;, &amp;num); //获取左旋的个数 scanf(&quot;%s&quot;, ch); //获取字符串 zuoxuan(ch, num); printf(&quot;%s\n&quot;, ch); return 0;&#125; 在写程序中遇到的问题：把指针没有解引用，一直对指针做运算，程序没有输出结果，发现是没有解引用。 习题2: 是否是旋转得到判断一个字符串是否为另外一个字符串旋转之后的字符串。例如：给定s1 ＝ AABCD和s2 = BCDAA，返回1，给定s1=abcd和s2=ACBD，返回0. AABCD左旋一个字符得到ABCDAAABCD左旋两个字符得到BCDAA AABCD右旋一个字符得到DAABC 理解：这个题目和第一个题目类似，上边的字符串右旋一个字符就相当于左旋两个字符。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;int judge(char *str1, char *str2, int size) //代码的缺点是在翻转时改变了原来的字符串&#123; char tmp; char *dst = str1; assert(str1); assert(str2); while(size) &#123; str1 = dst; if(strcmp(str1,str2) == 0) return 1; tmp = *str1; while(*(str1+1)) &#123; *str1 = *(str1+1); str1++; &#125; *str1 = tmp; size--; &#125; return 0;&#125;int main()&#123; char s1[] = &quot;ABCDEF&quot;; //源字符串 char s2[] = &quot;DEFABC&quot;; //要判断的字符串 int ret = 0; int size = strlen(s1); ret = judge(s1, s2, size); if(ret == 0) &#123; printf(&quot;No.\n&quot;); &#125; else &#123; printf(&quot;Yes.\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言练习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈帧与函数的调用]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[测试环境: vc2008 1、什么是栈 在计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop）,但栈这个容器必须遵守一条规则：先入栈的数据后出栈，多多少少像叠起来的一叠书，先叠上去的书在最下面，因此最后才能取出。 程序栈的简图 这里的ebp表示栈低寄器，esp表示栈顶寄存器，在栈上压入数据会导致esp减少，弹出数据会使得esp增大。相反，直接减小esp的值相当于开辟空间，增大esp的值相当于回收空间。 2、一个很常见的活动记录 活动记录 3、我们来看一个看例子 接下来，我们用一个简单的程序来说明函数的调用以及栈的布局 1234567891011121314151617181920#include &lt;stdio.h&gt;int fun(int a, int b)&#123; int z = a + b; return z;&#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c = fun(a, b); printf(&quot;c = %d&quot;, c); return 0;&#125; 这里我们直接进行调试，通过汇编代码能看的更去清楚。我们先从main函数开始 这里需要强调的是call命令，它有两个作用： 把当前指令的下一条指令的地址压入栈中 跳转到函数体执行到这里可能有人会想，cpu怎么知道我这会执行到那条代码，它是怎样计算的呢，在这里我们还需要知道一个寄存器，EIP寄存器（也叫程序计数器），它总是指向当前指令的下一条指令的地址。下来我们进入fun函数体 这样我就进入到了fun函数内部，当fun函数执行完时，执行123011013DD mov esp,ebp 011013DF pop ebp 011013E0 ret 使esp=ebp； 然后让 old ebp出栈，至此ebp就回到了main函数的ebp，ret从栈中去出返回地址，并跳到此处。101101429 add esp,8 紧接着又执行了这句，使esp指向main函数的栈顶。 fun函数的这段汇编代码基本分为下面几步：1.保存edp，让edp指向目前的栈顶1200E913B0 push ebp 00E913B1 mov ebp,esp 2.在栈上开辟一块空间100E913B3 sub esp,0CCh 3.保存ebx，esi，edi寄存器12300E913B9 push ebx 00E913BA push esi 00E913BB push edi 4.加入调试信息123400E913BC lea edi,[ebp-0CCh] 00E913C2 mov ecx,33h 00E913C7 mov eax,0CCCCCCCCh 00E913CC rep stos dword ptr es:[edi] 5.返回z，在这里是返回值通过eax寄存器传回100E913D7 mov eax,dword ptr [z] 6.从栈上恢复edi，esi，ebx寄存器12300E913DA pop edi 00E913DB pop esi 00E913DC pop ebx 7.恢复进入函数前的esp和edp1200E913DD mov esp,ebp 00E913DF pop ebp 8.使用ret指令返回100E913E0 ret 特别注意：main函数也是一个被调函数，因此调用它的过程和调用fun函数基本类似 4、通过栈帧修改ret返回的地址这里我们调用fun函数后，不让ret返回到main函数，而是修改它的地址，让他来到bug函数，将栈中存的返回地址保存到全局变量ret中，执行完bug函数后，让函数在返回main函数测试环境为vc6.0 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 执行结果如图： 但是一按回车就会出错，原因是call命令会把当前命令的下一条指令的地址压入栈中，执行完后会跳转到函数体。但是我们调用BUG函数时没有通过call命令调用，因此，我们少push一次，按回车后的esp应该指向的是main-esp-4；因此我们需要在main函数里调用完fun函数后将esp+4，保持栈帧平衡， 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); __asm &#123; sub esp, 4; &#125; printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 执行结果如图：]]></content>
      <categories>
        <category>c语言常见问题解析</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>栈帧</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018目标]]></title>
    <url>%2F2018%2F03%2F05%2F2018%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;今天是开学的第一天，大三的第二学期，再过半年就面临找工作了，由于自己想要找IT方面的工作，因此要付出更多的努力，今后一定不能浪费时间， 蓝桥杯&ensp;&ensp;&ensp;现在是3/15，距离蓝桥杯开始还有25天，我还没有做准备，今天晚上看了看题，很慌张，自己的C语言水平是如此的低，因此在这25天里，重点突击蓝桥杯，多做题，多思考，争取取得好成绩。 四级&ensp;&ensp;&ensp;从大一到现在已经考了三次四级，这次总算过了校线，前两次因为自己的英语差，以及裸考成绩都不如人意，这学期也将四级最为重点，争取在6月份考过四级，期待七月份的好成绩。 C++&ensp;&ensp;&ensp;从上学期十二月份开始，自己将方向定为C++，因为不喜欢本专业，也不考研，因此转向IT，之前学过C语言，搞过单片机，因为单片机对C语言的要求不高，因此我的C语言水平也比较差。从这学期开始，好好学习计算机类课程，提高自己的实力，争取在秋招找到一份好工作。 博客&ensp;&ensp;&ensp;定时的更新博客，每周至少写两篇技术博客，算是对自己学习的督促，和对知识的总结吧。 2018加油！ &ensp;&ensp;&ensp;&ensp;&ensp;fighting！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my blog 搭建完成]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[搭建博客一直都想有一个自己的博客，今使用 GitHub 时看见 GitHub+Hexo 也可以搭建静态博客，便产生了搭建博客的想法，于是便开始着手搭建。本博客于2018/3/1开始搭建，于2018/3/3基本搭建完成，后期继续优化。 搭建博客的目的用于写技术博客，也用于记录生活,后期会持续的定时更新博客。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.3.1]]></title>
    <url>%2F2018%2F03%2F01%2F2018-3-1%2F</url>
    <content type="text"><![CDATA[要狠心，要改过自新，要向前看，要赢。]]></content>
  </entry>
</search>
